(function () {
	"use strict";

	var ExtArr = require('./lib/extarr.js').ExtArr;
	var FrozenArr = require('./lib/frozenarr.js').FrozenArr;
	var Attributes = require('./lib/attributes.js').Attributes;
	var CONSTANTS = require('./lib/constants.js').CONSTANTS;
	var DataSet = require('./lib/dataset.js').DataSet;

	var contanerTypes = [CONSTANTS.ELEMENT_NODE, CONSTANTS.DOCUMENT_NODE, CONSTANTS.DOCUMENT_FRAGMENT_NODE];

	/*Constructors*/

	function DocumentType (name, publicId, systemId) {
		Object.defineProperties(this, {
			'name': {value: name, writable: false, enumerable: true, configurable: false},
			'publicId': {value: publicId || '', writable: false, enumerable: true, configurable: false},
			'systemId': {value: systemId || '', writable: false, enumerable: true, configurable: false}
		});
	}

	Object.defineProperty(DocumentType.prototype, 'toString', {
		value: function () {
			return "<!DOCTYPE " + this.name + (this.publicId ? " PUBLIC \"" + this.publicId + "\"" : "") + (this.systemId ? " \"" + this.systemId + "\"" : "") + ">";
		},
		writable: false,
		enumerable: false,
		configurable: false
	});

	function Node (tag, type) {
		/*Properties*/
		Object.defineProperties(this, {
			'tag': {value: contanerTypes.indexOf(type) >= 0? tag : '', writable: false, enumerable: true, configurable: false},
			'nodeName': {get: function () {return contanerTypes.indexOf(type) >= 0 ? ((this.ownerDocument || this).isHtml ? tag.toUpperCase() : tag) : '';}, enumerable: true, configurable: false},
			'nodeType': {value: type, writable: false, enumerable: true, configurable: false},
			'parentNode': {value: null, writable: true, enumerable: true, configurable: false},
			'childNodes': {value: new ExtArr(), writable: false, enumerable: true, configurable: false},
			'firstChild': {get: function () {return this.childNodes[0] || null;}, enumerable: true, configurable: false},
			'lastChild': {get: function () {return this.childNodes.last || null;}, enumerable: true, configurable: false},
			'nextSibling': {get: function () {
				if (!this.parentNode)
					return null;
				return this.parentNode.childNodes[this.parentNode.childNodes.position(this) + 1] || null;
			}, enumerable: true, configurable: false},
			'previousSibling': {get: function () {
				if (!this.parentNode)
					return null;
				return this.parentNode.childNodes[this.parentNode.childNodes.position(this) - 1] || null;
			}, enumerable: true, configurable: false},
			'nodeValue': {value: [CONSTANTS.TEXT_NODE, CONSTANTS.COMMENT_NODE].indexOf(type) >= 0 && ( tag || tag === 0 || tag === false) ? tag : '', writable: true, enumerable: true, configurable: false},
			'ownerDocument': {
				get: function () {
					if (this.nodeType === CONSTANTS.DOCUMENT_NODE)
						return null;
					return this._ownerDocument || null;
				},
				set: function (v) {
					if (this._ownerDocument)
						return;
					Object.defineProperty(this, '_ownerDocument', {value: v, writable: false, enumerable: false, configurable: true});
				}, enumerable: true, configurable: false
			},
			'textContent': {
				get: function () {
					switch (this.nodeType) {
						case CONSTANTS.TEXT_NODE:
						case CONSTANTS.COMMENT_NODE: return this.nodeValue; /*this.data*/
						case CONSTANTS.ELEMENT_NODE:
						case CONSTANTS.DOCUMENT_FRAGMENT_NODE: var str = [];
							for (var i = 0, l = this.childNodes.length; i < l; ++i)
								str.push(this.childNodes[i].textContent);
							return str.join(' ');
					}
				},
				set: function (v) {
					if (v.nodeType)
						v = v.textContent;
					else if (typeof v === 'object')
						v = v.toString();
					else
						v = '' + v;
					switch (this.nodeType) {
						case CONSTANTS.ELEMENT_NODE:
						case CONSTANTS.DOCUMENT_FRAGMENT_NODE: while (this.childNodes.length) this.childNodes.shift(); this.childNodes.push(text(v));
					}
				}, enumerable: true, configurable: false
			}
		});
	}
	Object.defineProperties(Node.prototype, {
		'appendChild': {
			value: function (elem) {
				if (elem.nodeType === CONSTANTS.DOCUMENT_FRAGMENT_NODE)
					for (var i = 0, l = elem.childNodes.length; i < l; ++i)
						this.appendChild(elem.childNodes[i]);
				if (elem.parentNode)
					elem.parentNode.removeChild(elem);
				this.childNodes.push(elem);
				elem.parentNode = this;
				return elem;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'cloneNode': {
			value: function (deep) {
				var clone;
				switch (this.nodeType) {
					case CONSTANTS.DOCUMENT_NODE:
					case CONSTANTS.ELEMENT_NODE: clone = element(this.tag, this.nodeType); break;
					case CONSTANTS.TEXT_NODE: clone = text(this.nodeValue); break;
					if (this.nodeType === CONSTANTS.ELEMENT_NODE) {
							/*Add code to coppy attributes*/
					}
					if (deep)
						for (var i = 0, l = this.childNodes.length; i < l; ++i)
							clone.appendChild(this.childNodes[i].cloneNode());
					return clone;
				}
			},writable: false, enumerable: true, configurable: false
		},
		'compareDocumentPosition': {
			value:function (other) {
				if (this === other)
					return CONSTANTS.DOCUMENT_POSITION_SAME;
				if ((this.ownerDocument || null) !== (other.ownerDocument || null))
					return CONSTANTS.DOCUMENT_POSITION_DISCONNECTED;
				if (this.nodeType === CONSTANTS.DOCUMENT_NODE)
					return CONSTANTS.DOCUMENT_POSITION_DISCONNECTED;
				var document = this.ownerDocument,
				    nodes = document.embeds,
				    compare, tmp;
				if (nodes.position(other) < nodes.position(this)) {
					compare = CONSTANTS.DOCUMENT_POSITION_PRECEDING;
					tmp = this;
					while (tmp = tmp.parentNode) {
						if (tmp = other)
							return compare && CONSTANTS.DOCUMENT_POSITION_CONTAINS;
					}
				} else {
					compare = CONSTANTS.DOCUMENT_POSITION_FOLLOWING;
					tmp = other;
					while (tmp = tmp.parentNode) {
						if (tmp = this)
							return compare && CONSTANTS.DOCUMENT_POSITION_CONTAINED_BY;
					}
				}
				return compare;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'hasChildNodes': {value: function () {return !!this.childNodes.length;}, writable: false, enumerable: true, configurable: false},
		'insertBefore': {
			value: function (newChild, refChild) {
				if (!this.childNodes.position(refChild))
					throw "refChild is not a child node";
				if (newChild.ownerDocument !== this.ownerDocument || newChild.ownerDocument !== this)
					return undefined;
				if (newChild.nodeType === CONSTANTS.DOCUMENT_FRAGMENT_NODE)
					for (var i = 0, l = newChild.childNodes.length; i < l; ++i)
						this.insertBefore(newChild.childNodes[i], refChild);
				if (newChild.parentNode)
					newChild.parentNode.removeChild(elem);
				if (!refChild)
					this.appendChild(newChild);
				else
					this.childNodes.insertBefore(newChild, removeChild);
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'isEqualNode': {
			value: function (other) {
				if (this === other)
					return true;
				if (this.nodeType !== other.nodeType || this.tag !== other.tag || this.nodeValue !== other.nodeValue)
					return false;
				if ((this.attributes && !other.attributes) || (other.attributes && !this.attributes))
					return false;
				else if (this.attributes && this.attributes.toString() !== other.attributes.toString())
					return false;
				if (this.childNodes.length !== other.childNodes.length)
					return false;
				for (var i = 0, l = this.childNodes.length; i < l; ++i)
					if (!this.childNodes[i].isEqual(other.childNodes[i]))
						return false;
				return true;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'isSameNode': {
			value: function (other) {return this === other;}, writable: false, enumerable: true, configurable: false
		},
		'normalize': {
			value: function () {
				var prev = null;
				for (var i = 0, l = this.childNodes.length; i < l; ++i) {
					var n = this.childNodes[i];
					if (n.nodeType === CONSTANTS.TEXT_NODE) {
						if (!prev) {
							prev = this.removeChild(n);
							if (!prev.nodeValue)
								prev = null;
						} else {
							prev = text(prev.nodeValue + n.nodeValue);
							this.removeChild(n);
						}
					} else if (prev) {
						this.insertBefore(prev, n);
						prev = null;
						}
					}
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'removeChild': {
			value: function (elem) {
				if (!this.childNodes.remove(elem))
					throw "Can not remove element which is not child";
				elem.parentNode = null;
				return elem;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'replaceChild': {
			value: function (newChild, oldChild) {
				this.insertBefore(newChild, oldChild);
				this.removeChild(oldChild);
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'toString': {
			value: function () {console.log(this.nodeType);
				var str;
				switch (this.nodeType) {
					case CONSTANTS.ELEMENT_NODE:
						str = '<' + this.tag;
						if (this.attributes.length)
							str += (' ' + this.attributes);
						if (!this.childNodes.length)
							return str + '/>';
						str += '>';
						for (var i = 0, l = this.childNodes.length; i < l; ++i)
							str += this.childNodes[i];
						return str + '</' + this.tag + '>';
					case CONSTANTS.TEXT_NODE: return this.nodeValue;
					case CONSTANTS.COMMENT_NODE: return '<!--' + this.nodeValue + '--!>';
					case CONSTANTS.DOCUMENT_NODE:
					case CONSTANTS.DOCUMENT_FRAGMENT_NODE:
						str = [];
						for (var i = 0, l = this.childNodes.length; i < l; ++i)
							str.push(childNodes[i].toString());
						return str.join('\n');
				}
			},
			writable: false,
			enumerable: false,
			configurable: false
		}
	});

	function Element (tag, type) {
		var node = new Node(tag, type || CONSTANTS.ELEMENT_NODE);
		for (var key in node) {
			if(!node.hasOwnProperty(key))
				continue;
			Object.defineProperty(this, key, Object.getOwnPropertyDescriptor(node, key));
		}
		Object.defineProperties(this, {
			'attributes': {value: new Attributes(), writable: false, enumerable: true, configurable: false},
			'childElementCount': {get: function () {return this.children.length}, enumerable: true, configurable: false},
			'children': {get: function () {
				var elements = new FrozenArr(),
				    nodes = this.childNodes;
				for (var i = 0, l = nodes.length; i < l; ++i) {
					var node = nodes[i];
					if (node.nodeType === CONSTANTS.ELEMENT_NODE)
						elements.push(node);
				}
				return elements.clear();
			}, enumerable: true, configurable: false},
			'classList': {get: function () {return this.attributes.getClassList();}, enumerable: true, configurable: false},
			'className': {
				get: function () {
					return this.classList.toString();
				},
				set: function (str) {
					this.attributes.set('class', str);
				},
				enumerable: true,
				configurable: false
			},
			'dataset': {
				get: function () {return new DataSet(this);},
				set: function (data) {
					var attrs = this.attributes,
					    _data = {};
					for (var key in data)
						_data[key] = data[key];
					for (var key in attrs)
						if (/^data\-\w+$/.test(key))
							attrs.remove(key);
					for (var key in _data)
						attrs.set(['data', key].join('-'), _data[key]);
				},
				enumerable: true,
				configurable: false
			},
			'firstElementChild': {get: function () {return this.children[0] || null;}, enumerable: true, configurable: false},
			'id': {
				get: function () {
					return this.attributes.id.value || null;
				},
				set: function (id) {
					this.attributes.set('id', id);
				},
				enumerable: true,
				configurable: false
			},
			'innerHTML': {
				get: function () {
					var str = [];
					for (var i = 0, l = this.childNodes.length; i < l; ++i)
						str.push(this.childNodes[i].toString());
					return str.join('');
				},
				enumerable: true,
				configurable: false
			},
			'lastElementChild': {get: function () {return this.children.last || null;}, enumerable: true, configurable: false},
			'localName': {get: function () {return this.tag;}, enumerable: true, configurable: false},
			'nextElementSibling': {get: function () {
				if (!this.parentNode)
					return null;
				return this.parentNode.children[this.parentNode.children.position(this) + 1] || null;
			}, enumerable: true, configurable: false},
			'outerHTML': {get: function () {return this.toString();}, enumerable: true, configurable: false},
			'previousElementSibling': {get: function () {
				if (!this.parentNode)
					return null;
				return this.parentNode.children[this.parentNode.children.position(this) - 1] || null;
			}, enumerable: true, configurable: false},
			'tagName': {get: function () {return this.nodeName;}, enumerable: true, configurable: false},
			'title': {
				get: function () {
					var t = this.attributes.get('title');
					return t ? t.value : '';
				},
				set: function (title) {
					this.attributes.set('title', title);
				},
				enumerable: true,
				configurable: false
			}
		});
	}

	Object.defineProperties(Element.prototype, {
		'getAttribute': {
			value: function (qualifiedName) {
				var attr = this.attributes.get(qualifiedName);
				return attr ? attr.value : null;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'getElementsByClassName': {
			value: function (classNames) {
				_classNames = classNames.split(' ');
				var res = [];
				m: for (var i = 0, l = this.children.length; i < l; ++i) {
					var elem = this.children[i],
					    classList = elem.classList;
					for (var j = 0, n = _classNames.length; j < n; ++j)
						if (!classList.contains(_classNames[j]))
							break m;
					res.push(elem);
					res = res.concat(elem.getElementsByClassName(classNames));
				}
				return res;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'getElementByTagName': {
			value: function (qualifiedName) {
				var res = [];
				for (var i = 0, l = this.children.length; i < l; ++i) {
					var elem = this.children[i];
					if (elem.tag === qualifiedName)
						res.push(elem);
					res = res.concat(elem.getElementByTagName(qualifiedName));
				}
				return res;
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'hasAttribute': {
			value: function (qualifiedName) {
				return !!this.attributes[qualifiedName];
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'insertAdjacentHTML': {
			value: function (position, text) {
				text = new Text(text);
				switch (position) {
					case 'beforebegin': this.parentNode.insertBefore(text, this); break;
					case 'afterend': this.parentNode.insertBefore(text, this.nextSibling); break;
					case 'afterbegin': this.insertBefore(text, this.firstChild); break;
					case 'beforeend': this.appendChild(text); break;
				}
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'removeAttribute': {
			value: function (qualifiedName) {
				this.attributes.remove(qualifiedName);
			},
			writable: false,
			enumerable: true,
			configurable: false
		},
		'setAttribute': {
			value: function (qualifiedName, value) {
				this.attributes.set(qualifiedName, value);
			}
		},
		'toString': Object.getOwnPropertyDescriptor(Node.prototype, 'toString')
	});
		

	function Text (value) {
		var node = new Node(tag, CONSTANTS.TEXT_NODE);
		for (var key in node) {
			if(!node.hasOwnProperty(key) && !{childNodes: 1, firstChild: 1, lastChild: 1}[key])
				continue;
			Object.defineProperty(this, key, Object.getOwnPropertyDescriptor(node, key));
		}
	}

	Object.defineProperty(Text.prototype, 'toString', Object.getOwnPropertyDescriptor(Node.prototype, 'toString'));

	function Comment (value) {
		var node = new Node(tag, CONSTANTS.COMMENT_NODE);
		for (var key in node) {
			if(!node.hasOwnProperty(key) && !{childNodes: 1, firstChild: 1, lastChild: 1}[key])
				continue;
			Object.defineProperty(this, key, Object.getOwnPropertyDescriptor(node, key));
		}
	}

	Object.defineProperty(Comment.prototype, 'toString', Object.getOwnPropertyDescriptor(Node.prototype, 'toString'));

	for (var key in Node.prototype) {
		Object.defineProperty(Element.prototype, key, Object.getOwnPropertyDescriptor(Node.prototype, key));
		if ({appendChild: 1, hasChildNodes: 1, insertBefore: 1, normalize: 1, removeChild: 1, replaceChild: 1}[key])
			continue;
		Object.defineProperty(Text.prototype, key, Object.getOwnPropertyDescriptor(Node.prototype, key));
		Object.defineProperty(Comment.prototype, key, Object.getOwnPropertyDescriptor(Node.prototype, key));
	}

	function Document (type, publicId, systemId) {
		var elem = new Element ('document', CONSTANTS.DOCUMENT_NODE);
		for (var key in elem) {
			if(!elem.hasOwnProperty(key))
				continue;
			Object.defineProperty(this, key, Object.getOwnPropertyDescriptor(elem, key));
		}
		Object.defineProperties(this, {
			'embeds': {
				get: function () {
					var n = new ExtArr();
					function _scan (node) {
						n.push(node);
						var c = node.childNodes;
						for (var i = 0, l = c.length; i < l; ++i)
							_scan(c[i]);
						return n;
					}
					return _scan(this);
				},
				enumerable: false,
				configurable: false
			}
		});
		if (type) {
			this.appendChild(new DocumentType(type, publicId, systemId));
			if (type === 'html')
				this.isHtml = true;
		}
	}

	for (var key in Element.prototype)
		Object.defineProperty(Document.prototype, key, Object.getOwnPropertyDescriptor(Element.prototype, key));
	Object.defineProperties(Document.prototype, {
		'createElement': {
			value: function (tag) {
				var elem = new Element(tag, CONSTANTS.ELEMENT_NODE);
				elem.ownerDocument = this;
				return elem;
			}
		}
	});

	Object.defineProperty(Document.prototype, 'toString', Object.getOwnPropertyDescriptor(Node.prototype, 'toString'));

	/*Creators*/

	exports.getDocument = function (type) {
		return new Document(type);
	};
}) ()