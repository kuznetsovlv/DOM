(function () {

	"use strict";

	var EventEmitter = require('events');
	var CONSTANTS = require('./constants.js');
	var NodeList = require('./nodelist.js');

	var contanerTypes = [CONSTANTS.ELEMENT_NODE, CONSTANTS.DOCUMENT_NODE, CONSTANTS.DOCUMENT_FRAGMENT_NODE];

	function remove (from, child) {
		if (!from.childNodes.remove(elem))
			return false;
		elem.parentNode = null;
		return true;
	}

	function append (to, child) {
		if (to.ownerDocument !== child.ownerDocument)
					return false;

				if (child.nodeType === CONSTANTS.DOCUMENT_FRAGMENT_NODE)
					while (child.childNodes.length)
						append(to, child.childNodes[0]);
				if (child.parentNode)
					remove(child.parentNode, child);
				to.childNodes.push(child);
				child.parentNode = to;
				return true;
	}

	function insertBefore(node, newChild, refChild) {
		if (newChild.nodeType === CONSTANTS.DOCUMENT_FRAGMENT_NODE)
			while (elem.childNodes.length)
				insertBefore(node, newChild.childNodes[0], refChild);
		if (newChild.parentNode)
			remove(newChild.parentNode, newChild);
		if (!refChild) {
			append(node, newChild);
		} else {
			node.childNodes.insertBefore(newChild, refChild);
			newChild.parentNode = node;
		}
	}

	class Node extends EventEmitter{
		constructor (tag, type) {
			super();
			Object.defineProperties(this, {
				'appendChild': {
					value: function (newChild) {
						append(this, newChild);
						this.emit('changed');
						return newChild;
					},
					writable: false,
					enumerable: true,
					configurable: true
				},
				'childNodes': {value: new NodeList(), writable: false, enumerable: true, configurable: true},
				'cloneNode': {
					value: function (deep) {/*nodeType dependable*/
						/*var clone;
						switch (this.nodeType) {
							case CONSTANTS.DOCUMENT_NODE: clone = this.implementation.createDocument(); break;
							case CONSTANTS.DOCUMENT_FRAGMENT_NODE: clone = this.ownerDocument.createDocumentFragment(); break;
							case CONSTANTS.ELEMENT_NODE: clone = this.ownerDocument.createElement(this.tag); break;
							case CONSTANTS.COMMENT_NODE: clone = this.ownerDocument.createComment(this.nodeValue); break;
						}
						if (this.attributes) {
								for (var i = 0, attrs = this.attributes, l = attrs.length; i < l; ++i) {
									var attr = attrs[i];
									clone.setAttribute(attr.localName, attr.value);
								}
						}
						if (deep)
							for (var i = 0, l = this.childNodes.length; i < l; ++i)
								clone.appendChild(this.childNodes[i].cloneNode(deep));
						return clone;*/
					},writable: false, enumerable: true, configurable: true
				},
				'compareDocumentPosition': {
					value:function (other) {
						if (this === other)
							return CONSTANTS.DOCUMENT_POSITION_SAME;
						if ((this.ownerDocument || null) !== (other.ownerDocument || null))
							return CONSTANTS.DOCUMENT_POSITION_DISCONNECTED;
						if (this.nodeType === CONSTANTS.DOCUMENT_NODE)
							return CONSTANTS.DOCUMENT_POSITION_DISCONNECTED;
						var document = this.ownerDocument,
						    nodes = document.embeds,
						    compare, tmp;
						if (nodes.position(other) < nodes.position(this)) {
							compare = CONSTANTS.DOCUMENT_POSITION_PRECEDING;
							tmp = this;
							while (tmp = tmp.parentNode) {
								if (tmp = other)
									return compare && CONSTANTS.DOCUMENT_POSITION_CONTAINS;
							}
						} else {
							compare = CONSTANTS.DOCUMENT_POSITION_FOLLOWING;
							tmp = other;
							while (tmp = tmp.parentNode) {
								if (tmp = this)
									return compare && CONSTANTS.DOCUMENT_POSITION_CONTAINED_BY;
							}
						}
						return compare;
					},
					writable: false,
					enumerable: true,
					configurable: false
				},
				'firstChild': {get: function () {return this.childNodes[0] || null;}, enumerable: true, configurable: true},
				'hasChildNodes': {value: function () {return !!this.childNodes.length;}, writable: false, enumerable: true, configurable: true},
				'insertBefore': {
					value: function (newChild, refChild) {
						if (refChild && this.childNodes.position(refChild) === undefined)
							throw "refChild is not a child node";
						if ((newChild.ownerDocument !== this.ownerDocument) && (newChild.ownerDocument !== this))
							return undefined;
						insertBefore(this, newChild, refChild);
						this.emit('changed');
					},
					writable: false,
					enumerable: true,
					configurable: true
				},
				'isEqualNode': {
					value: function (other) {
						if (this === other)
							return true;
						if (this.nodeType !== other.nodeType || this.tag !== other.tag || this.nodeValue !== other.nodeValue)
							return false;
						if ((this.attributes && !other.attributes) || (other.attributes && !this.attributes))
							return false;
						else if (this.attributes && this.attributes.toString() !== other.attributes.toString())
							return false;
						if (this.childNodes.length !== other.childNodes.length)
							return false;
						for (var i = 0, l = this.childNodes.length; i < l; ++i)
							if (!this.childNodes[i].isEqual(other.childNodes[i]))
								return false;
						return true;
					},
					writable: false,
					enumerable: true,
					configurable: true
				},
				'isSameNode': {value: function (other) {return this === other;}, writable: false, enumerable: true, configurable: false},
				'lastChild': {get: function () {return this.childNodes.last || null;}, enumerable: true, configurable: true},
				'nextSibling': {
					get: function () {
						if (!this.parentNode)
							return null;
						return this.parentNode.childNodes[this.parentNode.childNodes.position(this) + 1] || null;
					},
					enumerable: true,
					configurable: false
				},
				'nodeName': {
					get: function () {
						var doctype = (this.ownerDocument || this).doctype;
						return contanerTypes.indexOf(this.nodeType) >= 0 ? ((doctype ? /html/i.test(doctype.name) : false) ? this.tag.toUpperCase() : this.tag) : '';
					},
					enumerable: true,
					configurable: false
				},
				'nodeType': {value: type, writable: false, enumerable: true, configurable: false},
				'nodeValue': {value: [CONSTANTS.TEXT_NODE, CONSTANTS.COMMENT_NODE].indexOf(type) >= 0 && ( tag || tag === 0 || tag === false) ? tag : '', writable: true, enumerable: true, configurable: false},
				'normalize': {
					value: function () {
						var prev = null,
						    document = this.nodeType === CONSTANTS.DOCUMENT_NODE ? this : this.ownerDocument;
						if (!document)
							return;
						for (var i = 0, l = this.childNodes.length; i < l; ++i) {
							var n = this.childNodes[i];
							if (n.nodeType === CONSTANTS.TEXT_NODE) {
								if (!prev) {
									remove(this, n);
									prev = n;
									if (!prev.nodeValue)
										prev = null;
								} else {
									prev = document.createTextNode(prev.nodeValue + n.nodeValue);
									remove(this, n);
								}
							} else if (prev) {
								insertBefore(this, prev, n);
								prev = null;
							}
						}
						this.emit('changed');
					},
					writable: false,
					enumerable: true,
					configurable: true
				},
				'ownerDocument': {
					get: function () {
						if (this.nodeType === CONSTANTS.DOCUMENT_NODE)
							return null;
						return this._ownerDocument || null;
					},
					set: function (v) {
						if (this._ownerDocument || !v)
							return;
						this.emit('adopt', v);
					},
					enumerable: true,
					configurable: false
				},
				'parentNode': {value: null, writable: true, enumerable: true, configurable: false},
				'previousSibling': {get: function () {
						if (!this.parentNode)
							return null;
						return this.parentNode.childNodes[this.parentNode.childNodes.position(this) - 1] || null;
					},
					enumerable: true,
					configurable: false
				},
				'removeChild': {
					value: function (oldChild) {
						if (!remove(this, oldChild))
							throw "Can not remove element which is not child";
						this.emit('changed');
						return oldChild;
					},
					writable: false,
					enumerable: true,
					configurable: true
				},
				'replaceChild': {
					value: function (newChild, oldChild) {
						insertBefore(this, newChild, oldChild);
						removeChild(this, oldChild);
						this.emit('changed');
					},
					writable: false,
					enumerable: true,
					configurable: true
				},
				'tag': {value: contanerTypes.indexOf(type) >= 0 || type === CONSTANTS.DOCUMENT_TYPE_NODE ? tag : '', writable: false, enumerable: true, configurable: false},
				'textContent': {
					get: function () {/*nodeType dependable*/
					/*
						switch (this.nodeType) {
							case CONSTANTS.COMMENT_NODE: return this.nodeValue;
							case CONSTANTS.ELEMENT_NODE:
							case CONSTANTS.DOCUMENT_NODE:
							case CONSTANTS.DOCUMENT_FRAGMENT_NODE: var str = [];
								for (var i = 0, l = this.childNodes.length; i < l; ++i)
									str.push(this.childNodes[i].textContent);
								return str.join(' ');
						}*/
					},
					set: function (v) {/*nodeType dependable*/
					/*
						if (v.nodeType)
							v = v.textContent;
						else if (typeof v === 'object')
							v = v.toString();
						else
							v = '' + v;
						switch (this.nodeType) {
							case CONSTANTS.ELEMENT_NODE:
							case CONSTANTS.DOCUMENT_FRAGMENT_NODE: while (this.childNodes.length) this.childNodes.shift(); this.childNodes.push(text(v));
						}*/
					}, enumerable: true, configurable: true
				},
				'toString': {
					value: function () {/*nodeType dependable*/
						/*var str;
						switch (this.nodeType) {
							case CONSTANTS.ELEMENT_NODE:
								str = '<' + this.tag;
								if (this.attributes.length)
									str += (' ' + this.attributes);
								if (!this.childNodes.length)
									return str + '/>';
								str += '>';
								for (var i = 0, l = this.childNodes.length; i < l; ++i)
									str += this.childNodes[i];
								return str + '</' + this.tag + '>';
							case CONSTANTS.COMMENT_NODE: return '<!--' + this.nodeValue + '--!>';
							case CONSTANTS.DOCUMENT_NODE:
							case CONSTANTS.DOCUMENT_FRAGMENT_NODE:
								str = [];
								for (var i = 0, l = this.childNodes.length; i < l; ++i)
									str.push(this.childNodes[i].toString());
								return str.join('\n');
						}*/
					},
					writable: false,
					enumerable: false,
					configurable: true
				}
			});
			this.on('adopt', function (ownerDocument) {
				Object.defineProperty(this, '_ownerDocument', {value: ownerDocument, writable: false, enumerable: false, configurable: true});
				for (var i = 0, l = this.childNodes.length; i < l; ++i)
					this.childNodes[i].emit('adopt', ownerDocument);
			});
			this.on('changed', function () {
				if (this.parentNode)
					this.parentNode.emit('changed');
			});
		}
	};

	module.exports = Node;
})()